codebase-retrieval
- code search results with memory-store entries (notes, docs) for richer context.
- You want code spans plus relevant memories in one response.
- Prefer repo_search for code-only; use context_answer when you need an LLM-written answer.

repo_search
- Zero-config code search over repositories (hybrid: vector + lexical RRF, optional rerank).
- Find relevant code spans quickly; prefer this over embedding-only search.
- Use context_answer when you need a synthesized explanation; use codebase-retrieval to blend with memory notes.

context_answer
- Natural-language Q&A over the repo using retrieval + local LLM (llama.cpp).
- Retrieves relevant code (hybrid vector+lexical with ReFRAG gate-first).
- Budgets/merges micro-spans, builds citations, and asks the LLM to answer.
- Returns a concise answer plus file/line citations.
- You need an explanation or "how to" grounded in code.
- Prefer repo_search for raw hits; prefer codebase-retrieval to blend code + memory.

```json
{
  "method": "tools/call",
  "params": {
    "name": "repo_search",
    "arguments": {
      "limit": 20,
      "per_path": null,
      "include_snippet": true,
      "context_lines": 20,
      "rerank_enabled": true,
      "rerank_top_n": null,
      "rerank_return_m": null,
      "rerank_timeout_ms": null,
      "highlight_snippet": null,
      "collection": null,
      "workspace_path": null,
      "session": null,
      "language": null,
      "under": null,
      "kind": null,
      "symbol": null,
      "path_regex": null,
      "path_glob": null,
      "not_glob": null,
      "ext": null,
      "not_": null,
      "case": null,
      "compact": null,
      "kwargs": null
    },
    "_meta": {
      "progressToken": 2
    }
  }
}
```

# Tooling Reference
This document summarizes the tools I can invoke while working in this environment.

## Shell-Level Commands
- `functions.shell_command` — runs a PowerShell command in the project workspace; include `with_escalated_permissions` only when absolutely necessary and justify it. Prefer avoiding direct shell commands by using higher-level tools when possible.

## File Modification
- `functions.apply_patch` — applies precise edits by describing hunks (`*** Begin Patch` ... `*** End Patch`). Use this for source changes unless generating files would be easier with another approach (e.g., mass rename, autogenerated files). Do not wrap the patch payload in JSON and obey the patch grammar rules.

## MCP Resource Navigation
- `functions.list_mcp_resources` — lists available shared resources from configured MCP servers.
- `functions.list_mcp_resource_templates` — enumerates MCP resource templates that parameterize reusable info.
- `functions.read_mcp_resource` — fetches the contents of a specific MCP resource once you know its URI.

## Planning and Context
- `functions.update_plan` — records and updates a multi-step plan when tasks justify one (skip plans for trivial work). Only one step may be in progress at a time.
- `functions.mcp__auggie-context__query_codebase` — queries the codebase via Auggie CLI for structure, behavior, or documentation details.

## Supporting Utilities
- `functions.view_image` — attaches a local image to the conversation for visual context when needed.

## General Guidelines
- Prefer higher-level tools over raw shell access.
- Respect instructions from AGENT docs (e.g., lint/run commands for specific directories).
- Keep edits ASCII unless Unicode is already present for a clear reason.
